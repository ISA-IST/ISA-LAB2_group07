mat = [[(pp,0,0), (s,0)], [(pp,0,1)], [(pp,0,2), (pp,1,

% (pp,0,0) => pp0(0)   "pp0(0)"
% (s,0) => s(0)
% (s',0) => not(s(0))


ha_1_0 : ha port map (A=>pp13(0), B=>s(13), S=>sum_1(0), C_out=>carry_1(0));
% sum_1(35 downto 0)

%(sum,1,0) @ i, (carry, 1,0) @i+1

if(var(0)= sum)


pseudo codice

for ogni target

scorri le colonne di matr con i
if (len(i)+carry_precedenti) > target (contando carry precedenti, se aggiungiamo a capo non serve)
	for j in (lunghezza-target)/2  % while len > target+1
		% estraiamo i tre ultimi valori e li comprimiamo
		% instanziamo un full adder (fare funzione che decodifica i segnali e scrive il vhdl) (passando una sottostringa, numadd e targetindex)
		fa_#targetindex_#numadd: fa port map (A=>matr[i](len-1), B=>matr[i](len-2), C=>matr[i](len-3), S=>sum_#targetindex_#numadd, C_out=>carry#targetindex_#numadd)
		matr[i].insert(sum_#targetindex_#numadd)  %aggiungiamo a capo della colonna attuale il bit di somma
		matr[i+1].insert(carry_#targetindex_#numadd) %aggiungiamo a capo della colonna successiva il bit di carry
		numadd_#targetindex ++

	% per sapere se istanziare l'HA basta controllare se len attuale è ancora più lunga di target (al max sarà len+1)
	if len > target	
		ha port map (A=>matr[i](len-1), B=>matr[i](len-2), S=>sum_#targetindex_#numadd, C_out=>carry#targetindex_#numadd)
		matr[i].insert(sum_#targetindex_#numadd)  %aggiungiamo a capo della colonna attuale il bit di somma
		matr[i+1].insert(carry_#targetindex_#numadd) %aggiungiamo a capo della colonna successiva il bit di carry
		numadd_#targetindex ++
		
